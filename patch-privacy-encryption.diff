diff --git a/src/App.tsx b/src/App.tsx
--- a/src/App.tsx
+++ b/src/App.tsx
@@
 /* -------------------- TYPES & DATA MODELS -------------------- */
@@
-type JournalEntry = {
-  id: string;
-  isoDateTime: string; // e.g., 2025-09-23T07:45:00-07:00
-  text?: string;       // empty if they checked "Done on paper"
-  onPaper?: boolean;   // true when they marked done without typing
-  sharedTo?: ("spouse" | "pastor")[]; // optional, per-entry sharing
-};
+type JournalEntry = {
+  id: string;
+  isoDateTime: string; // e.g., 2025-09-23T07:45:00-07:00
+  encrypted?: { iv: string; blob: string }; // AES-GCM encrypted JSON: { text: string }
+  onPaper?: boolean;   // true when they marked done without typing
+  // sharedTo?: ("spouse" | "pastor")[]; // (optional future)
+};
@@
-type PrivacyPrefs = {
-  allowPastorView: boolean; // master toggle for leader/mentor visibility of anonymized metrics
-};
+type PrivacyPrefs = {
+  allowPastorView: boolean; // master toggle for leader/mentor visibility of anonymized metrics
+  pinEnabled?: boolean;
+  autoLockMinutes?: 5 | 10 | 30 | 60;
+  consentLog?: Array<{ at: number; allow: boolean }>;
+  // shareCode?: string; // optional future
+};
@@
 export type UserState = {
   version: number;
   completedHabits: Partial<Record<MicroHabitId, string[]>>;
   assessmentScores: Partial<Record<"cooperative" | "avoidant" | "competitive", number>>;
   selectedVerseTopic: VerseTopic;
@@
   // NEW — Journaling (optional so older blobs load fine)
   journal?: {
     entries: JournalEntry[];
     prefs: JournalPrefs;
   };
 
   // NEW — Privacy (optional; default provided in load/migrate)
   privacy?: PrivacyPrefs;
 };
 
+// ===== Defaults for new fields =====
+export const DEFAULT_PRIVACY: PrivacyPrefs = {
+  allowPastorView: false,
+  pinEnabled: false,
+  autoLockMinutes: 10,
+  consentLog: [],
+};
+export const DEFAULT_JOURNAL: NonNullable<UserState["journal"]> = {
+  entries: [],
+  prefs: { remindDaily: false, remindTime: "20:30", remindAfterWorkflow: false, historyView: "list" },
+};
+
@@
-export const STORAGE_KEY = "trueglue.v2.user";
-export const STORAGE_VERSION = 3;
+export const STORAGE_KEY = "trueglue.v2.user";
+export const STORAGE_VERSION = 4;
@@
 function migrate(old: any): UserState | null {
   if (old && typeof old === "object") {
     if (old.version === 1) {
       return {
-        version: STORAGE_VERSION,
+        version: STORAGE_VERSION,
         completedHabits: old.completedHabits ?? {},
         assessmentScores: old.assessmentScores ?? {},
         selectedVerseTopic: "unity",
         stylePrimary: old.stylePrimary,
         styleSecondary: old.styleSecondary,
         profile: old.profile ?? undefined,
-        journal: old.journal ?? DEFAULT_JOURNAL,
-        privacy: old.privacy ?? DEFAULT_PRIVACY,
+        journal: old.journal ?? DEFAULT_JOURNAL,
+        privacy: old.privacy ?? DEFAULT_PRIVACY,
       };
     }
     if (old.version === 2) {
       return {
-        version: STORAGE_VERSION,
+        version: STORAGE_VERSION,
         completedHabits: old.completedHabits ?? {},
         assessmentScores: old.assessmentScores ?? {},
         selectedVerseTopic: old.selectedVerseTopic ?? "unity",
         stylePrimary: old.stylePrimary,
         styleSecondary: old.styleSecondary,
         profile: old.profile ?? undefined,
-        journal: old.journal ?? DEFAULT_JOURNAL,
-        privacy: old.privacy ?? DEFAULT_PRIVACY,
+        journal: old.journal ?? DEFAULT_JOURNAL,
+        privacy: old.privacy ?? DEFAULT_PRIVACY,
       };
     }
+    if (old.version === 3) {
+      return {
+        version: STORAGE_VERSION,
+        completedHabits: old.completedHabits ?? {},
+        assessmentScores: old.assessmentScores ?? {},
+        selectedVerseTopic: old.selectedVerseTopic ?? "unity",
+        stylePrimary: old.stylePrimary,
+        styleSecondary: old.styleSecondary,
+        profile: old.profile ?? undefined,
+        journal: old.journal ?? DEFAULT_JOURNAL,
+        privacy: old.privacy ?? DEFAULT_PRIVACY,
+      };
+    }
   }
   return null;
 }
@@
 export function loadState(): UserState {
   try {
     const raw = localStorage.getItem(STORAGE_KEY);
     if (!raw) throw new Error("none");
     const parsed = JSON.parse(raw);
 
     if (parsed.version === STORAGE_VERSION) return parsed as UserState;
 
     const migrated = migrate(parsed);
     if (migrated) {
       localStorage.setItem(STORAGE_KEY, JSON.stringify(migrated));
       return migrated;
     }
     // wipe incompatible
     localStorage.removeItem(STORAGE_KEY);
     throw new Error("mismatch");
   } catch {
-  return {
-  version: STORAGE_VERSION,
-  completedHabits: {},
-  assessmentScores: {},
-  selectedVerseTopic: "unity",
-  journal: DEFAULT_JOURNAL,         // ← add
-  privacy: DEFAULT_PRIVACY,         // existing
-};
+    return {
+      version: STORAGE_VERSION,
+      completedHabits: {},
+      assessmentScores: {},
+      selectedVerseTopic: "unity",
+      journal: DEFAULT_JOURNAL,
+      privacy: DEFAULT_PRIVACY,
+    };
   }
 }
@@
-// TODO: Replace base64 with AES-GCM using Web Crypto API when moving off local-only storage.
-
-// --- base64 helpers without deprecated escape/unescape ---
-const te = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
-const td = typeof TextDecoder !== "undefined" ? new TextDecoder() : null;
-
-function toBase64(u8: Uint8Array): string {
-  let bin = "";
-  for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
-  return btoa(bin);
-}
-function fromBase64(b64: string): Uint8Array {
-  const bin = atob(b64);
-  const u8 = new Uint8Array(bin.length);
-  for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
-  return u8;
-}
-
-function encodeText(plain: string): string {
-  try {
-    if (te) return toBase64(te.encode(plain));
-    // very old browsers fallback
-    return btoa(unescape(encodeURIComponent(plain)));
-  } catch {
-    return plain;
-  }
-}
-function decodeText(encoded: string): string {
-  try {
-    if (td) return td.decode(fromBase64(encoded));
-    // very old browsers fallback
-    return decodeURIComponent(escape(atob(encoded)));
-  } catch {
-    return encoded;
-  }
-}
+// ===== Strong crypto (AES-GCM with PIN-derived key) =====
+async function deriveKeyFromPin(pin: string, saltB64: string) {
+  const enc = new TextEncoder();
+  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(pin), "PBKDF2", false, ["deriveKey"]);
+  const salt = Uint8Array.from(atob(saltB64), c => c.charCodeAt(0));
+  return crypto.subtle.deriveKey(
+    { name: "PBKDF2", salt, iterations: 210_000, hash: "SHA-256" },
+    keyMaterial,
+    { name: "AES-GCM", length: 256 },
+    false,
+    ["encrypt", "decrypt"]
+  );
+}
+async function encryptJSONWithKey(key: CryptoKey, data: unknown) {
+  const iv = crypto.getRandomValues(new Uint8Array(12));
+  const enc = new TextEncoder();
+  const cipher = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(JSON.stringify(data)));
+  return { iv: btoa(String.fromCharCode(...iv)), blob: btoa(String.fromCharCode(...new Uint8Array(cipher))) };
+}
+async function decryptJSONWithKey<T>(key: CryptoKey, payload: { iv: string; blob: string }): Promise<T> {
+  const iv = Uint8Array.from(atob(payload.iv), c => c.charCodeAt(0));
+  const bytes = Uint8Array.from(atob(payload.blob), c => c.charCodeAt(0));
+  const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, bytes);
+  return JSON.parse(new TextDecoder().decode(new Uint8Array(plain)));
+}
+let SESSION_AES_KEY: CryptoKey | null = null;
+function getOrCreateSaltB64() {
+  const k = "trueglue.v2.salt";
+  let s = localStorage.getItem(k);
+  if (!s) {
+    const bytes = crypto.getRandomValues(new Uint8Array(16));
+    s = btoa(String.fromCharCode(...bytes));
+    localStorage.setItem(k, s);
+  }
+  return s;
+}
+function isLocked(u: UserState) {
+  return !!u.privacy?.pinEnabled && !SESSION_AES_KEY;
+}
@@
 function AppTabs({ route, setRoute }: AppTabsProps) {
@@
   return (
     <Tabs
       label="Main navigation"
       value={route}
       onChange={setRoute}
       items={items}
       pillStyle={pillStyleThemed}
       activePillStyle={activePillStyleThemed}
     />
   );
 }
 
@@
 function Profile() {
@@
-{/* NEW: Privacy & Sharing */}
-<Card title="Privacy & Sharing" sub="Control what is visible to pastors/mentors.">
+{/* NEW: Privacy & Sharing */}
+<Card title="Privacy & Sharing" sub="Control what is visible to pastors/mentors and secure your data with a PIN.">
   <div style={{ display: "grid", gap: 10 }}>
     <label style={{ display: "flex", alignItems: "center", gap: 8 }}>
       <input
         type="checkbox"
         checked={user.privacy?.allowPastorView ?? false}
-        onChange={(e) =>
-          setUser({
-            ...user,
-            privacy: { allowPastorView: e.currentTarget.checked },
-          })
-        }
+        onChange={(e) => {
+          const allow = e.currentTarget.checked;
+          setUser({
+            ...user,
+            privacy: {
+              ...(user.privacy ?? DEFAULT_PRIVACY),
+              allowPastorView: allow,
+              consentLog: [...(user.privacy?.consentLog ?? []), { at: Date.now(), allow }],
+            },
+          });
+        }}
       />
       <span>Allow pastor/mentor to view my anonymized metrics</span>
     </label>
+    {user.privacy?.consentLog?.length ? (
+      <div style={{ fontSize: 12, color: T.muted }}>
+        Last change: {new Date(user.privacy!.consentLog!.at(-1)!.at).toLocaleString()}
+      </div>
+    ) : null}
 
     <div style={{ fontSize: 12, color: T.muted, lineHeight: 1.5 }}>
       <div>• Journal entries are private by default and stored locally on this device.</div>
       <div>• Only group-level counts (e.g., habit completions, number of journal entries) are shown.</div>
       <div>• You can turn this off anytime.</div>
     </div>
+
+    <div style={{ borderTop: `1px solid ${T.soft}`, marginTop: 12, paddingTop: 12 }}>
+      <div style={{ fontWeight: 600, marginBottom: 6 }}>App PIN & Auto-lock</div>
+
+      <label style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
+        <input
+          type="checkbox"
+          checked={!!user.privacy?.pinEnabled}
+          onChange={async (e) => {
+            const enable = e.currentTarget.checked;
+            const next = {
+              ...user,
+              privacy: {
+                ...(user.privacy ?? DEFAULT_PRIVACY),
+                pinEnabled: enable,
+                consentLog: user.privacy?.consentLog ?? [],
+              },
+            };
+            setUser(next);
+            if (enable) {
+              const pin = prompt("Set a 4–6 digit PIN:");
+              if (pin && /^\d{4,6}$/.test(pin)) {
+                const salt = getOrCreateSaltB64();
+                SESSION_AES_KEY = await deriveKeyFromPin(pin, salt);
+                toast("PIN set & session unlocked");
+              } else {
+                toast("Invalid PIN format");
+              }
+            } else {
+              SESSION_AES_KEY = null;
+              toast("PIN disabled");
+            }
+          }}
+        />
+        <span>Enable App PIN (required to view journal text)</span>
+      </label>
+
+      <label style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 8 }}>
+        <span style={{ fontSize: 13, color: T.muted, width: 180 }}>Auto-lock after</span>
+        <select
+          value={user.privacy?.autoLockMinutes ?? 10}
+          onChange={(e) =>
+            setUser({
+              ...user,
+              privacy: { ...(user.privacy ?? DEFAULT_PRIVACY), autoLockMinutes: Number(e.currentTarget.value) as any },
+            })
+          }
+          style={{ padding: "6px 8px", borderRadius: 8, border: `1px solid ${T.soft}`, background: "transparent", color: T.text }}
+        >
+          {[5,10,30,60].map(m => <option key={m} value={m}>{m} minutes</option>)}
+        </select>
+      </label>
+
+      {!SESSION_AES_KEY && user.privacy?.pinEnabled && (
+        <button
+          type="button"
+          onClick={async () => {
+            const pin = prompt("Enter PIN to unlock");
+            if (!pin) return;
+            try {
+              const salt = getOrCreateSaltB64();
+              SESSION_AES_KEY = await deriveKeyFromPin(pin, salt);
+              toast("Unlocked");
+            } catch {
+              toast("Could not unlock");
+            }
+          }}
+          style={{ padding: "8px 12px", borderRadius: 999, border: `1px solid ${T.primary}`, background: "transparent", color: T.text, fontSize: 13 }}
+        >
+          Unlock with PIN
+        </button>
+      )}
+    </div>
+
+    <div style={{ borderTop: `1px solid ${T.soft}`, marginTop: 12, paddingTop: 12 }}>
+      <div style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
+        <button
+          type="button"
+          onClick={() => {
+            const data = loadState();
+            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
+            const url = URL.createObjectURL(blob);
+            const a = document.createElement("a");
+            a.href = url;
+            a.download = `trueglue-export-${new Date().toISOString().slice(0,10)}.json`;
+            a.click();
+            URL.revokeObjectURL(url);
+          }}
+          style={{ padding: "8px 12px", borderRadius: 999, border: `1px solid ${T.primary}`, background: "transparent", color: T.text, fontSize: 13 }}
+        >Export (JSON)</button>
+
+        <button
+          type="button"
+          onClick={() => {
+            if (!confirm("Delete all local data on this device? This cannot be undone.")) return;
+            localStorage.removeItem(STORAGE_KEY);
+            // keep salt so re-import with the same PIN can decrypt; remove key below for full wipe:
+            // localStorage.removeItem("trueglue.v2.salt");
+            window.location.reload();
+          }}
+          style={{ padding: "8px 12px", borderRadius: 999, border: `1px solid ${T.soft}`, background: "transparent", color: T.text, fontSize: 13 }}
+        >Delete all data</button>
+      </div>
+    </div>
   </div>
 </Card>
@@
 function JournalHistoryModal({
@@
-                {e.text
-  ? <div style={{ whiteSpace: "pre-wrap", lineHeight: 1.5 }}>{decodeText(e.text)}</div>
-  : <em style={{ color: T.muted }}>No text (paper entry)</em>}
+                {e.onPaper ? (
+                  <em style={{ color: T.muted }}>No text (paper entry)</em>
+                ) : e.encrypted ? (
+                  SESSION_AES_KEY ? (
+                    <DecryptedText payload={e.encrypted} />
+                  ) : (
+                    <em style={{ color: T.muted }}>Locked — enter PIN to view</em>
+                  )
+                ) : (
+                  <em style={{ color: T.muted }}>No text</em>
+                )}
               </div>
             ))}
           </div>
@@
 function JournalHabitModal({
@@
-  const saveText = (opts?: { onPaper?: boolean }) => {
+  const saveText = async (opts?: { onPaper?: boolean }) => {
     const u = ensureJournalBucket(user);
-    const entry: JournalEntry = {
-      id: Math.random().toString(36).slice(2),
-      isoDateTime: nowISOWithTZ(),
-      text: opts?.onPaper ? "" : encodeText(text.trim()),
-      onPaper: !!opts?.onPaper,
-    };
+    let encrypted: { iv: string; blob: string } | undefined = undefined;
+    if (!opts?.onPaper) {
+      if (!SESSION_AES_KEY && u.privacy?.pinEnabled) {
+        toast("Unlock with your PIN first");
+        return;
+      }
+      const key = SESSION_AES_KEY
+        ? SESSION_AES_KEY
+        : await deriveKeyFromPin("0000", getOrCreateSaltB64()); // fallback if no PIN enabled yet
+      encrypted = await encryptJSONWithKey(key, { text: text.trim() });
+    }
+    const entry: JournalEntry = {
+      id: Math.random().toString(36).slice(2),
+      isoDateTime: nowISOWithTZ(),
+      encrypted,
+      onPaper: !!opts?.onPaper,
+    };
     const next: UserState = {
       ...u,
       journal: { ...u.journal!, entries: [entry, ...u.journal!.entries], prefs: u.journal!.prefs },
     };
     setUser(next);
     completeHabit("journal");   // mark the habit
     onSaved();
     toast(opts?.onPaper ? "Marked done (paper)" : "Journal saved");
     onClose();
   };
@@
   );
 }
 
+// Small helper to render decrypted journal text
+function DecryptedText({ payload }: { payload: { iv: string; blob: string } }) {
+  const [txt, setTxt] = React.useState<string>("(decrypting…)");
+  React.useEffect(() => {
+    let alive = true;
+    (async () => {
+      try {
+        const key = SESSION_AES_KEY ?? await deriveKeyFromPin("0000", getOrCreateSaltB64());
+        const obj = await decryptJSONWithKey<{ text: string }>(key, payload);
+        if (alive) setTxt(obj.text);
+      } catch {
+        if (alive) setTxt("(unable to decrypt)");
+      }
+    })();
+    return () => { alive = false; };
+  }, [payload]);
+  return <div style={{ whiteSpace: "pre-wrap", lineHeight: 1.5 }}>{txt}</div>;
+}
+
@@
 function AppShell() {
@@
   useEffect(() => {
   const id = window.setTimeout(() => saveState(user), 200);
   return () => window.clearTimeout(id);
 }, [user]);
@@
   const api = useMemo<AppCtx>(
@@
   [user, toast]   // ✅ include toast
 );
 
+  // Auto-lock session AES key after inactivity (only when PIN enabled)
+  useEffect(() => {
+    const minutes = user.privacy?.autoLockMinutes ?? 10;
+    if (!user.privacy?.pinEnabled) return;
+    let timer: number | null = null;
+    const reset = () => {
+      if (timer) window.clearTimeout(timer);
+      timer = window.setTimeout(() => { SESSION_AES_KEY = null; }, minutes * 60 * 1000);
+    };
+    const events = ["mousemove", "keydown", "click", "visibilitychange"];
+    events.forEach((ev) => window.addEventListener(ev, reset));
+    reset();
+    return () => {
+      if (timer) window.clearTimeout(timer);
+      events.forEach((ev) => window.removeEventListener(ev, reset));
+    };
+  }, [user.privacy?.pinEnabled, user.privacy?.autoLockMinutes]);
+
   return (
@@
 function ChurchPanel() {
 const T = useT();
   const { user } = useApp(); // NEW
 
-// NEW — anonymized counts only (no names, no content)
-const habitDayCount = Object.values(user.completedHabits ?? {}).reduce(
-  (acc, arr) => acc + (arr?.length ?? 0),
-  0
-);
-const journalCount = user.journal?.entries?.length ?? 0;
+// NEW — single source of truth for anonymized metrics
+function computeAnonymizedMetrics(u: UserState) {
+  const habitDayCount = Object.values(u.completedHabits ?? {}).reduce((acc, arr) => acc + (arr?.length ?? 0), 0);
+  const journalCount = u.journal?.entries?.length ?? 0;
+  const journalDaysLast30 = (() => {
+    const set = new Set<string>();
+    const cutoff = Date.now() - 30 * 86400_000;
+    (u.journal?.entries ?? []).forEach(e => {
+      const t = new Date(e.isoDateTime).getTime();
+      if (t >= cutoff) set.add(e.isoDateTime.slice(0,10));
+    });
+    return set.size;
+  })();
+  const conflictsResolved = 0; // placeholder until conflict records are tracked
+  return { habitDayCount, journalCount, journalDaysLast30, conflictsResolved, updatedAt: Date.now() };
+}
+const m = computeAnonymizedMetrics(user);
@@
-{user.privacy?.allowPastorView && (
+{user.privacy?.allowPastorView && (
   <Card title="Group Metrics (Anonymized)">
     <ul style={{ margin: 0, paddingLeft: 18, lineHeight: 1.6 }}>
-      <li>Total habit completions (count): {habitDayCount}</li>
-      <li>Total journal entries (count only): {journalCount}</li>
+      <li>Total habit completions (count): {m.habitDayCount}</li>
+      <li>Total journal entries (count only): {m.journalCount}</li>
+      <li>Journal days (last 30): {m.journalDaysLast30}</li>
     </ul>
     <div style={{ marginTop: 6, fontSize: 12, color: T.muted }}>
       These are counts only. No names, emails, or journal text are shared.
     </div>
   </Card>
 )}
